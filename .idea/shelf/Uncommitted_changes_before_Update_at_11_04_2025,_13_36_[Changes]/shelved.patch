Index: test/ch/epfl/rechor/journey/MyEtape7Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.epfl.rechor.journey;\n\n\nimport ch.epfl.rechor.timetable.CachedTimeTable;\nimport ch.epfl.rechor.timetable.Stations;\nimport ch.epfl.rechor.timetable.TimeTable;\nimport ch.epfl.rechor.timetable.mapped.FileTimeTable;\n\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.time.LocalDate;\nimport java.time.Month;\n\npublic final class MyEtape7Test {\n    public static void main(String[] args) throws IOException {\n        long tStart = System.nanoTime();\n\n        TimeTable timeTable = new CachedTimeTable(FileTimeTable.in(Path.of(\"timetable 3\")));\n        Stations stations = timeTable.stations();\n\n        LocalDate date = LocalDate.of(2025, Month.APRIL, 1);\n\n        //int depStationId = stationId(stations, \"Ecublens VD, EPFL\");\n        int depStationId = stationId(stations, \"Lausanne\");\n        int arrStationId = stationId(stations, \"Genève\");\n        //int arrStationId = stationId(stations, \"Gruyères\");\n\n        Router router = new Router(timeTable);\n        Profile profile = router.profile(date, arrStationId);\n\n        //Journey journey = JourneyExtractor.journeys(profile, depStationId).get(32);\n        var journeys = JourneyExtractor.journeys(profile, depStationId);\n        if(journeys.isEmpty()) {\n            System.out.println(\"No journeys found\");\n        }\n        for(Journey journey : journeys) {\n            System.out.println(JourneyIcalConverter.toIcalendar(journey));\n        }\n\n\n        double elapsed = (System.nanoTime() - tStart) * 1e-9;\n        System.out.printf(\"Temps écoulé : %.3f s%n\", elapsed);\n    }\n\n    // Utilitaire pour retrouver l'identifiant d'une station par son nom\n    private static int stationId(Stations stations, String stationName) {\n        for (int i = 0; i < stations.size(); i++) {\n            if (stations.name(i).equals(stationName)) return i;\n        }\n        throw new IllegalArgumentException(\"Station inconnue : \" + stationName);\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/ch/epfl/rechor/journey/MyEtape7Test.java b/test/ch/epfl/rechor/journey/MyEtape7Test.java
--- a/test/ch/epfl/rechor/journey/MyEtape7Test.java	(revision c065bdbd247e8baf03341c0c33271ac541f7c4fa)
+++ b/test/ch/epfl/rechor/journey/MyEtape7Test.java	(date 1744304879716)
@@ -16,7 +16,7 @@
     public static void main(String[] args) throws IOException {
         long tStart = System.nanoTime();
 
-        TimeTable timeTable = new CachedTimeTable(FileTimeTable.in(Path.of("timetable 3")));
+        TimeTable timeTable = new CachedTimeTable(FileTimeTable.in(Path.of("timetable_14")));
         Stations stations = timeTable.stations();
 
         LocalDate date = LocalDate.of(2025, Month.APRIL, 1);
@@ -48,6 +48,6 @@
         for (int i = 0; i < stations.size(); i++) {
             if (stations.name(i).equals(stationName)) return i;
         }
-        throw new IllegalArgumentException("Station inconnue : " + stationName);
+        return -1; // Station non trouvée
     }
 }
\ No newline at end of file
Index: src/ch/epfl/rechor/journey/JourneyExtractor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.epfl.rechor.journey;\n\nimport ch.epfl.rechor.timetable.*;\n\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\nimport static ch.epfl.rechor.Bits32_24_8.unpack24;\nimport static ch.epfl.rechor.Bits32_24_8.unpack8;\nimport static ch.epfl.rechor.journey.PackedCriteria.*;\n\n/**\n * Classe qui extrait des voyages concrets à partir des données de profil.\n * Convertit les critères de la frontière de Pareto en objets Journey avec\n * des étapes de transport et à pied.\n *\n * @author Sarra Zghal, Elyes Ben Abid\n *\n */\npublic class JourneyExtractor {\n\n    private JourneyExtractor() {\n    }\n\n    /**\n     * Extrait une liste de voyages à partir d'un profil et d'un identifiant de station de départ.\n     *\n     * @param profile      Le profil contenant les données de voyage optimales\n     * @param depStationId L'identifiant de la station de départ\n     * @return Une liste de voyages possibles entre la station de départ et la destination du profil\n     */\n    public static List<Journey> journeys(Profile profile, int depStationId) {\n        // Liste pour stocker les voyages extraits\n        List<Journey> journeys = new ArrayList<>();\n\n        // Récupération des informations du profil\n        int arrStationId = profile.arrStationId();\n        ParetoFront initialPf = profile.forStation(depStationId);\n        TimeTable tt = profile.timeTable();\n        LocalDate date = profile.date();\n\n        // Récupération des composants nécessaires de l'horaire\n        Connections connections = tt.connectionsFor(date);\n        Trips trips = tt.tripsFor(date);\n        Routes routes = tt.routes();\n        Stations stations = tt.stations();\n        Platforms platforms = tt.platforms();\n        Transfers transfers = tt.transfers();\n\n        // Traitement de chaque critère dans la frontière de Pareto\n        initialPf.forEach((long criteria) -> {\n            // Pour chaque critère, on crée un nouveau voyage avec une liste d'étapes vide\n            List<Journey.Leg> legs = new ArrayList<>();\n\n            // Extraction des informations du critère\n            int depTime = depMins(criteria);              // Heure de départ en minutes\n            int targetArrTime = arrMins(criteria);        // Heure d'arrivée cible en minutes\n            int remainingChanges = changes(criteria);     // Nombre de changements restants\n\n            // Extraction et validation des données de la charge utile (payload)\n            int payload = payload(criteria);\n\n            // Extraction de l'ID de connexion (24 bits) et validation\n            int connectionID = unpack24(payload);\n\n            // Extraction du nombre d'arrêts intermédiaires (8 bits) et validation\n            int nbOfIntermediateStops = unpack8(payload);\n\n            // Configuration initiale pour la création du voyage\n            int firstStopId = connections.depStopId(connectionID);\n            int currentStationId = depStationId;\n            int firstStationID = tt.stationId(firstStopId);\n\n            // Détermination si un transfert à pied initial est nécessaire\n            // Deux cas possibles:\n            // 1. La station de départ n'est pas la même que la station de la première connexion\n            // 2. Le premier arrêt est un quai (et non une station)\n            boolean needsInitialFootTransfer = currentStationId != firstStationID;\n\n            // Ajout d'une étape à pied initiale si nécessaire\n            if (needsInitialFootTransfer) {\n                legs.add(createFootLeg(profile, currentStationId, firstStationID,\n                        createTime(depTime, date), transfers));\n                currentStationId = firstStationID; // Mise à jour de la station courante\n            }\n\n            // Boucle principale: traitement de chaque connexion\n            while (remainingChanges >= 0) {\n                // Récupération des détails de la connexion\n                int depStopId = connections.depStopId(connectionID);\n                int arrStopId = connections.arrStopId(connectionID);\n                int tripId = connections.tripId(connectionID);\n                int routeId = trips.routeId(tripId);\n\n                // Récupération des informations sur la route, le véhicule et la destination\n                String route = routes.name(routeId);\n                Vehicle vehicle = routes.vehicle(routeId);\n                String destination = trips.destination(tripId);\n\n                // Traitement des arrêts intermédiaires\n                List<Journey.Leg.IntermediateStop> intermediateStops = new ArrayList<>();\n                int nextConnectionId = connectionID;\n\n                // Création exactement du nombre d'arrêts intermédiaires spécifié dans le payload\n                for (int j = 0; j < nbOfIntermediateStops; j++) {\n                    // Récupération des informations sur l'arrêt intermédiaire\n                    int interStopId = connections.arrStopId(nextConnectionId);\n\n                    LocalDateTime interArrTime = createTime(connections.arrMins(nextConnectionId)\n                            , date);\n\n                    int tempNextConnectionId = connections.nextConnectionId(nextConnectionId);\n                    if (tempNextConnectionId != -1) {\n                        nextConnectionId = tempNextConnectionId;\n                    } else {\n                        // Si pas de connexion suivante, on sort de la boucle\n                        break;\n                    }\n\n                    LocalDateTime interDepTime = createTime(connections.depMins(nextConnectionId)\n                            , date);\n\n                    // Création d'un objet Stop pour la station intermédiaire\n                    int stationId = tt.stationId(interStopId);\n                    String stationName = tt.stations().name(stationId);\n                    String platformName = tt.platformName(interStopId);\n                    double longitude = tt.stations().longitude(stationId);\n                    double latitude = tt.stations().latitude(stationId);\n\n                    Stop intermediateStop = new Stop(stationName, platformName, longitude,\n                            latitude);\n\n                    // Gestion des heures d'arrivée/départ pour respecter la contrainte:\n                    // l'heure d'arrivée doit être avant l'heure de départ\n                    if (interArrTime.isAfter(interDepTime)) {\n                        // Échange des heures pour éviter une exception lors de la création de\n                        // IntermediateStop\n                        LocalDateTime temp = interArrTime;\n                        interArrTime = interDepTime;\n                        interDepTime = temp;\n                    }\n\n                    // Ajout de l'arrêt intermédiaire à la liste\n                    intermediateStops.add(new Journey.Leg.IntermediateStop(\n                            intermediateStop,\n                            interArrTime,\n                            interDepTime\n                    ));\n\n                    // Mise à jour de l'arrêt d'arrivée pour la connexion suivante\n                    arrStopId = connections.arrStopId(nextConnectionId);\n                }\n\n                // Création des heures de départ et d'arrivée pour l'étape de transport\n                LocalDateTime tripDepTime = createTime(connections.depMins(connectionID), date);\n                LocalDateTime tripArrTime = createTime(connections.arrMins(nextConnectionId), date);\n\n                // Création des objets Stop pour le départ et l'arrivée\n                Stop depStop = createStop(tt, stations, platforms, depStopId);\n                Stop arrStop = createStop(tt, stations, platforms, arrStopId);\n\n                // Création et ajout de l'étape de transport\n                Journey.Leg leg = new Journey.Leg.Transport(depStop, tripDepTime, arrStop,\n                        tripArrTime, intermediateStops, vehicle, route, destination);\n                legs.add(leg);\n\n                // Mise à jour de la station courante\n                currentStationId = tt.stationId(arrStopId);\n\n\n                // Traitement de l'arrivée et des transferts\n                if (currentStationId != arrStationId) {\n                    remainingChanges--;\n\n                    // Préparation pour la prochaine connexion\n                    ParetoFront nextStationFront = profile.forStation(currentStationId);\n\n\n                    // Protection contre les potentielles exceptions NoSuchElementException\n                    try {\n                        long nextCriteria;\n\n                        nextCriteria = nextStationFront.get(targetArrTime, remainingChanges);\n                        // Mise à jour des données pour la prochaine connexion\n                        depTime = depMins(nextCriteria);\n                        connectionID = unpack24(payload(nextCriteria));\n                        nbOfIntermediateStops = unpack8(payload(nextCriteria));\n\n                        int nextDepStopId = connections.depStopId(connectionID);\n                        int nextDepStationId = tt.stationId(nextDepStopId);\n\n                        // Ajout d'une étape à pied vers la destination finale\n                        legs.add(createFootLeg(profile, currentStationId, nextDepStationId,\n                                tripArrTime, transfers));\n\n\n                        // Conversion de l'ID d'arrêt en ID de station\n                        currentStationId = nextDepStationId;\n\n                    } catch (NoSuchElementException e) {\n                        // Si aucun critère n'est trouvé, on termine ce voyage\n                        legs.add(createFootLeg(profile, currentStationId, arrStationId,\n                                tripArrTime, transfers));\n                        journeys.add(new Journey(legs));\n                        break;\n                    }\n\n                } else {\n                    // Si nous sommes directement à la station de destination\n                    journeys.add(new Journey(legs));\n                    break;\n                }\n            }\n\n\n        });\n\n        // Tri des voyages par heure de départ, puis par heure d'arrivée\n        journeys.sort(Comparator.comparing(Journey::depTime).thenComparing(Journey::arrTime));\n\n        return journeys;\n    }\n\n    /**\n     * Crée une étape à pied entre deux stations.\n     *\n     * @param profile       Profil contenant les données de l'horaire\n     * @param fromStationId ID de la station de départ\n     * @param toStationId   ID de la station d'arrivée\n     * @param depTime       Heure de départ\n     * @param transfers     Données sur les transferts entre stations\n     * @return Une étape à pied (Foot leg)\n     */\n    private static Journey.Leg.Foot createFootLeg(Profile profile, int fromStationId,\n                                                  int toStationId, LocalDateTime depTime,\n                                                  Transfers transfers) {\n        Stations stations = profile.timeTable().stations();\n        Platforms platforms = profile.timeTable().platforms();\n\n        // Création des objets Stop pour le départ et l'arrivée\n        Stop depStop = createStop(profile.timeTable(), stations, platforms, fromStationId);\n        Stop arrStop = createStop(profile.timeTable(), stations, platforms, toStationId);\n\n        // Récupération du temps de marche entre stations\n        int walkingMinutes;\n        walkingMinutes = transfers.minutesBetween(fromStationId, toStationId);\n\n        // Calcul de l'heure d'arrivée\n        LocalDateTime arrTime = depTime.plusMinutes(walkingMinutes);\n\n        // Création et retour de l'étape à pied\n        return new Journey.Leg.Foot(depStop, depTime, arrStop, arrTime);\n    }\n\n    /**\n     * Crée un objet Stop à partir d'un ID d'arrêt.\n     *\n     * @param tt        Horaire contenant les données des stations et plateformes\n     * @param stations  Stations indexées\n     * @param platforms Plateformes indexées\n     * @param stopId    ID de l'arrêt\n     * @return Un objet Stop représentant l'arrêt\n     */\n    private static Stop createStop(TimeTable tt, Stations stations, Platforms platforms,\n                                   int stopId) {\n        // Utilisation des méthodes de l'interface TimeTable pour gérer les stopIds\n        int stationId = tt.stationId(stopId);\n        String platformName = tt.platformName(stopId);\n\n        // Création et retour de l'objet Stop\n        return new Stop(\n                stations.name(stationId),\n                platformName,\n                stations.longitude(stationId),\n                stations.latitude(stationId)\n        );\n    }\n\n    /**\n     * Convertit un temps en minutes après minuit en LocalDateTime.\n     *\n     * @param timeAfterMidnight Minutes après minuit\n     * @param date              Date de référence\n     * @return DateTime représentant le temps spécifié\n     */\n    private static LocalDateTime createTime(int timeAfterMidnight, LocalDate date) {\n        return date.atStartOfDay().plusMinutes(timeAfterMidnight);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ch/epfl/rechor/journey/JourneyExtractor.java b/src/ch/epfl/rechor/journey/JourneyExtractor.java
--- a/src/ch/epfl/rechor/journey/JourneyExtractor.java	(revision c065bdbd247e8baf03341c0c33271ac541f7c4fa)
+++ b/src/ch/epfl/rechor/journey/JourneyExtractor.java	(date 1744099197118)
@@ -249,6 +249,7 @@
         int walkingMinutes;
         walkingMinutes = transfers.minutesBetween(fromStationId, toStationId);
 
+
         // Calcul de l'heure d'arrivée
         LocalDateTime arrTime = depTime.plusMinutes(walkingMinutes);
 
